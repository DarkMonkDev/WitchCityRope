#!/usr/bin/env python3
"""
Automated Vulnerability Scanner
Integrates multiple security scanning tools for comprehensive vulnerability assessment
"""

import os
import sys
import json
import subprocess
import argparse
import threading
import queue
import time
from datetime import datetime
from typing import Dict, List, Tuple, Optional
import xml.etree.ElementTree as ET
import requests
import re
from concurrent.futures import ThreadPoolExecutor, as_completed

class VulnerabilityScanner:
    def __init__(self, target: str, scan_type: str = 'full'):
        self.target = target
        self.scan_type = scan_type
        self.results = {
            'target': target,
            'scan_type': scan_type,
            'timestamp': datetime.now().isoformat(),
            'vulnerabilities': [],
            'summary': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0,
                'info': 0
            }
        }
        self.scan_id = datetime.now().strftime('%Y%m%d_%H%M%S')
        self.output_dir = f"scan_results_{self.scan_id}"
        os.makedirs(self.output_dir, exist_ok=True)
        
    def run_command(self, command: List[str], timeout: int = 300) -> Tuple[int, str, str]:
        """Execute system command with timeout"""
        try:
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            stdout, stderr = process.communicate(timeout=timeout)
            return process.returncode, stdout, stderr
        except subprocess.TimeoutExpired:
            process.kill()
            return -1, "", "Command timed out"
        except Exception as e:
            return -1, "", str(e)
            
    def check_tool_availability(self) -> Dict[str, bool]:
        """Check which security tools are available"""
        tools = {
            'nmap': ['nmap', '--version'],
            'nikto': ['nikto', '-Version'],
            'sqlmap': ['sqlmap', '--version'],
            'gobuster': ['gobuster', 'version'],
            'testssl': ['testssl', '--version'],
            'nuclei': ['nuclei', '-version'],
            'rustscan': ['rustscan', '--version'],
            'ffuf': ['ffuf', '-V']
        }
        
        available = {}
        for tool, command in tools.items():
            try:
                result = subprocess.run(
                    command,
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                available[tool] = result.returncode == 0
            except:
                available[tool] = False
                
        return available
        
    def nmap_scan(self) -> List[Dict]:
        """Perform Nmap vulnerability scan"""
        print("[*] Running Nmap scan...")
        vulnerabilities = []
        
        # Define Nmap commands for different scan types
        if self.scan_type == 'quick':
            nmap_cmd = [
                'nmap', '-sV', '-T4', '--top-ports', '1000',
                '-oX', f"{self.output_dir}/nmap_scan.xml",
                self.target
            ]
        else:
            nmap_cmd = [
                'nmap', '-sV', '-sC', '-O', '-A',
                '--script', 'vuln,exploit,auth,default',
                '-oX', f"{self.output_dir}/nmap_scan.xml",
                self.target
            ]
            
        returncode, stdout, stderr = self.run_command(nmap_cmd, timeout=600)
        
        if returncode == 0:
            # Parse Nmap XML output
            try:
                tree = ET.parse(f"{self.output_dir}/nmap_scan.xml")
                root = tree.getroot()
                
                for host in root.findall('.//host'):
                    ip = host.find('.//address[@addrtype="ipv4"]').get('addr')
                    
                    # Check for open ports
                    for port in host.findall('.//port'):
                        if port.find('state').get('state') == 'open':
                            port_id = port.get('portid')
                            protocol = port.get('protocol')
                            service = port.find('service')
                            service_name = service.get('name', 'unknown') if service is not None else 'unknown'
                            
                            # Check for vulnerable services
                            vuln_services = ['telnet', 'ftp', 'vnc', 'rdp', 'smb']
                            if service_name.lower() in vuln_services:
                                vulnerabilities.append({
                                    'tool': 'nmap',
                                    'type': 'Insecure Service',
                                    'severity': 'HIGH',
                                    'host': ip,
                                    'port': f"{port_id}/{protocol}",
                                    'service': service_name,
                                    'description': f"Potentially insecure service {service_name} detected",
                                    'recommendation': f"Disable {service_name} or use secure alternative"
                                })
                                
                    # Parse script results
                    for script in host.findall('.//script'):
                        script_id = script.get('id')
                        output = script.get('output', '')
                        
                        # Check for specific vulnerabilities
                        if 'VULNERABLE' in output or 'vulnerable' in output:
                            vulnerabilities.append({
                                'tool': 'nmap',
                                'type': 'Script Detection',
                                'severity': 'HIGH',
                                'host': ip,
                                'script': script_id,
                                'description': output.strip(),
                                'recommendation': 'Review and patch identified vulnerability'
                            })
                            
            except Exception as e:
                print(f"[!] Error parsing Nmap results: {e}")
                
        return vulnerabilities
        
    def nikto_scan(self) -> List[Dict]:
        """Perform Nikto web vulnerability scan"""
        print("[*] Running Nikto scan...")
        vulnerabilities = []
        
        nikto_cmd = [
            'nikto', '-h', self.target,
            '-output', f"{self.output_dir}/nikto_scan.json",
            '-Format', 'json',
            '-Tuning', '123456789' if self.scan_type == 'full' else '12'
        ]
        
        returncode, stdout, stderr = self.run_command(nikto_cmd, timeout=900)
        
        if returncode == 0:
            # Parse Nikto results
            try:
                # Nikto output parsing (simplified - real implementation would be more robust)
                for line in stdout.split('\n'):
                    if '+ OSVDB-' in line or '+ CVE-' in line:
                        vulnerabilities.append({
                            'tool': 'nikto',
                            'type': 'Web Vulnerability',
                            'severity': 'MEDIUM',
                            'host': self.target,
                            'description': line.strip(),
                            'recommendation': 'Review and address identified issue'
                        })
            except Exception as e:
                print(f"[!] Error parsing Nikto results: {e}")
                
        return vulnerabilities
        
    def testssl_scan(self) -> List[Dict]:
        """Perform SSL/TLS vulnerability scan"""
        print("[*] Running TestSSL scan...")
        vulnerabilities = []
        
        testssl_cmd = [
            'testssl', '--json-pretty',
            '--file', f"{self.output_dir}/testssl_scan.json",
            self.target
        ]
        
        returncode, stdout, stderr = self.run_command(testssl_cmd, timeout=600)
        
        if returncode == 0:
            try:
                with open(f"{self.output_dir}/testssl_scan.json", 'r') as f:
                    results = json.load(f)
                    
                # Check for SSL/TLS vulnerabilities
                vuln_checks = {
                    'heartbleed': ('Heartbleed', 'CRITICAL'),
                    'poodle_ssl': ('POODLE SSL', 'HIGH'),
                    'robot': ('ROBOT', 'HIGH'),
                    'sweet32': ('SWEET32', 'MEDIUM'),
                    'logjam': ('Logjam', 'HIGH'),
                    'drown': ('DROWN', 'HIGH')
                }
                
                for check, (name, severity) in vuln_checks.items():
                    if check in results and results[check].get('finding') == 'VULNERABLE':
                        vulnerabilities.append({
                            'tool': 'testssl',
                            'type': 'SSL/TLS Vulnerability',
                            'severity': severity,
                            'host': self.target,
                            'vulnerability': name,
                            'description': f"Server is vulnerable to {name} attack",
                            'recommendation': f"Patch SSL/TLS implementation to fix {name}"
                        })
                        
            except Exception as e:
                print(f"[!] Error parsing TestSSL results: {e}")
                
        return vulnerabilities
        
    def nuclei_scan(self) -> List[Dict]:
        """Perform Nuclei template-based scanning"""
        print("[*] Running Nuclei scan...")
        vulnerabilities = []
        
        # Update templates first
        update_cmd = ['nuclei', '-update-templates']
        self.run_command(update_cmd, timeout=120)
        
        nuclei_cmd = [
            'nuclei', '-target', self.target,
            '-json', '-output', f"{self.output_dir}/nuclei_scan.json"
        ]
        
        if self.scan_type == 'quick':
            nuclei_cmd.extend(['-severity', 'critical,high'])
        else:
            nuclei_cmd.extend(['-severity', 'critical,high,medium,low'])
            
        returncode, stdout, stderr = self.run_command(nuclei_cmd, timeout=1200)
        
        if os.path.exists(f"{self.output_dir}/nuclei_scan.json"):
            try:
                with open(f"{self.output_dir}/nuclei_scan.json", 'r') as f:
                    for line in f:
                        try:
                            finding = json.loads(line)
                            vulnerabilities.append({
                                'tool': 'nuclei',
                                'type': finding.get('type', 'Unknown'),
                                'severity': finding.get('severity', 'MEDIUM').upper(),
                                'host': finding.get('host', self.target),
                                'template': finding.get('template-id', ''),
                                'name': finding.get('name', ''),
                                'description': finding.get('description', ''),
                                'recommendation': finding.get('remediation', 'Review and patch')
                            })
                        except:
                            continue
            except Exception as e:
                print(f"[!] Error parsing Nuclei results: {e}")
                
        return vulnerabilities
        
    def directory_fuzzing(self) -> List[Dict]:
        """Perform directory and file discovery"""
        print("[*] Running directory fuzzing...")
        vulnerabilities = []
        
        # Common wordlist for quick scan
        wordlist = "/usr/share/wordlists/dirb/common.txt"
        if not os.path.exists(wordlist):
            wordlist = "common.txt"
            # Create basic wordlist if system wordlist not found
            with open(wordlist, 'w') as f:
                f.write('\n'.join([
                    'admin', 'administrator', 'backup', 'config', 'dashboard',
                    'debug', 'test', 'temp', 'tmp', 'upload', 'uploads',
                    '.git', '.env', '.config', 'wp-admin', 'phpmyadmin'
                ]))
                
        gobuster_cmd = [
            'gobuster', 'dir',
            '-u', self.target,
            '-w', wordlist,
            '-o', f"{self.output_dir}/gobuster_scan.txt",
            '-x', 'php,asp,aspx,jsp,html,js,txt,xml,json',
            '-t', '50' if self.scan_type == 'full' else '10'
        ]
        
        returncode, stdout, stderr = self.run_command(gobuster_cmd, timeout=600)
        
        if returncode == 0 and os.path.exists(f"{self.output_dir}/gobuster_scan.txt"):
            try:
                with open(f"{self.output_dir}/gobuster_scan.txt", 'r') as f:
                    for line in f:
                        if 'Status: 200' in line or 'Status: 403' in line:
                            path = line.split()[0]
                            
                            # Check for sensitive files/directories
                            sensitive_patterns = [
                                ('.git', 'Git Repository Exposed', 'CRITICAL'),
                                ('.env', 'Environment File Exposed', 'CRITICAL'),
                                ('backup', 'Backup Files/Directory', 'HIGH'),
                                ('admin', 'Admin Interface Exposed', 'HIGH'),
                                ('config', 'Configuration Files', 'HIGH'),
                                ('debug', 'Debug Information', 'MEDIUM'),
                                ('test', 'Test Files/Directory', 'LOW')
                            ]
                            
                            for pattern, desc, severity in sensitive_patterns:
                                if pattern in path.lower():
                                    vulnerabilities.append({
                                        'tool': 'gobuster',
                                        'type': 'Information Disclosure',
                                        'severity': severity,
                                        'host': self.target,
                                        'path': path,
                                        'description': f"{desc} found at {path}",
                                        'recommendation': f"Remove or restrict access to {path}"
                                    })
                                    break
                                    
            except Exception as e:
                print(f"[!] Error parsing Gobuster results: {e}")
                
        return vulnerabilities
        
    def check_headers(self) -> List[Dict]:
        """Check for missing security headers"""
        print("[*] Checking security headers...")
        vulnerabilities = []
        
        try:
            response = requests.get(self.target, timeout=10, verify=False)
            headers = response.headers
            
            # Required security headers
            required_headers = {
                'Strict-Transport-Security': ('HSTS Missing', 'HIGH'),
                'X-Frame-Options': ('Clickjacking Protection Missing', 'MEDIUM'),
                'X-Content-Type-Options': ('MIME Sniffing Protection Missing', 'MEDIUM'),
                'Content-Security-Policy': ('CSP Missing', 'HIGH'),
                'X-XSS-Protection': ('XSS Protection Missing', 'LOW'),
                'Referrer-Policy': ('Referrer Policy Missing', 'LOW')
            }
            
            for header, (desc, severity) in required_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'tool': 'header_check',
                        'type': 'Missing Security Header',
                        'severity': severity,
                        'host': self.target,
                        'header': header,
                        'description': desc,
                        'recommendation': f"Implement {header} header"
                    })
                    
            # Check for information disclosure headers
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in disclosure_headers:
                if header in headers:
                    vulnerabilities.append({
                        'tool': 'header_check',
                        'type': 'Information Disclosure',
                        'severity': 'LOW',
                        'host': self.target,
                        'header': header,
                        'value': headers[header],
                        'description': f"Server information disclosed via {header} header",
                        'recommendation': f"Remove {header} header"
                    })
                    
        except Exception as e:
            print(f"[!] Error checking headers: {e}")
            
        return vulnerabilities
        
    def sql_injection_scan(self) -> List[Dict]:
        """Basic SQL injection detection"""
        print("[*] Checking for SQL injection vulnerabilities...")
        vulnerabilities = []
        
        # This is a basic check - real scanning would use sqlmap
        test_payloads = [
            "'", '"', "' OR '1'='1", '" OR "1"="1',
            "' OR '1'='1' --", "' OR '1'='1' #",
            "1' ORDER BY 1--", "1' UNION SELECT NULL--"
        ]
        
        try:
            # Get forms from the target page
            response = requests.get(self.target, timeout=10, verify=False)
            
            # Simple form detection (real implementation would parse HTML properly)
            if '<form' in response.text.lower():
                for payload in test_payloads[:3]:  # Limited testing
                    test_url = f"{self.target}?id={payload}"
                    try:
                        test_response = requests.get(test_url, timeout=5, verify=False)
                        
                        # Check for SQL error messages
                        sql_errors = [
                            'mysql_fetch', 'Warning: mysql', 'MySqlException',
                            'valid MySQL result', 'mssql_query()', 'MySqlClient',
                            'PostgreSQL', 'valid PostgreSQL result',
                            'Warning: pg_', 'PG::SyntaxError',
                            'SQLite error', 'sqlite3.OperationalError',
                            'Microsoft OLE DB Provider for ODBC Drivers',
                            'Microsoft OLE DB Provider for SQL Server',
                            'Incorrect syntax near', 'Sintaxis incorrecta cerca de'
                        ]
                        
                        for error in sql_errors:
                            if error.lower() in test_response.text.lower():
                                vulnerabilities.append({
                                    'tool': 'sql_check',
                                    'type': 'SQL Injection',
                                    'severity': 'CRITICAL',
                                    'host': self.target,
                                    'parameter': 'id',
                                    'payload': payload,
                                    'description': f"Possible SQL injection vulnerability detected",
                                    'recommendation': 'Use parameterized queries and input validation'
                                })
                                break
                                
                    except:
                        continue
                        
        except Exception as e:
            print(f"[!] Error in SQL injection scan: {e}")
            
        return vulnerabilities
        
    def aggregate_results(self, all_vulnerabilities: List[Dict]):
        """Aggregate and deduplicate vulnerability findings"""
        # Simple deduplication based on type and host
        seen = set()
        unique_vulns = []
        
        for vuln in all_vulnerabilities:
            key = (vuln.get('type'), vuln.get('host'), vuln.get('description', '')[:50])
            if key not in seen:
                seen.add(key)
                unique_vulns.append(vuln)
                
                # Update summary
                severity = vuln.get('severity', 'INFO').lower()
                if severity in self.results['summary']:
                    self.results['summary'][severity] += 1
                    
        self.results['vulnerabilities'] = unique_vulns
        
    def generate_report(self):
        """Generate comprehensive vulnerability report"""
        # JSON report
        json_report = f"{self.output_dir}/vulnerability_report.json"
        with open(json_report, 'w') as f:
            json.dump(self.results, f, indent=2)
            
        # HTML report
        html_report = f"{self.output_dir}/vulnerability_report.html"
        self._generate_html_report(html_report)
        
        # Text summary
        text_report = f"{self.output_dir}/vulnerability_summary.txt"
        self._generate_text_summary(text_report)
        
        print(f"\n[+] Reports generated in {self.output_dir}/")
        
    def _generate_html_report(self, filename: str):
        """Generate HTML vulnerability report"""
        severity_colors = {
            'CRITICAL': '#d32f2f',
            'HIGH': '#f44336',
            'MEDIUM': '#ff9800',
            'LOW': '#ffc107',
            'INFO': '#2196f3'
        }
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }}
        .container {{
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        h1, h2 {{
            color: #333;
        }}
        .summary {{
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }}
        .summary-item {{
            flex: 1;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            color: white;
        }}
        .critical {{ background-color: {severity_colors['CRITICAL']}; }}
        .high {{ background-color: {severity_colors['HIGH']}; }}
        .medium {{ background-color: {severity_colors['MEDIUM']}; }}
        .low {{ background-color: {severity_colors['LOW']}; }}
        .info {{ background-color: {severity_colors['INFO']}; }}
        .vulnerability {{
            margin: 15px 0;
            padding: 15px;
            border-left: 4px solid #ddd;
            background-color: #fafafa;
        }}
        .vulnerability.critical {{ border-color: {severity_colors['CRITICAL']}; }}
        .vulnerability.high {{ border-color: {severity_colors['HIGH']}; }}
        .vulnerability.medium {{ border-color: {severity_colors['MEDIUM']}; }}
        .vulnerability.low {{ border-color: {severity_colors['LOW']}; }}
        .vulnerability.info {{ border-color: {severity_colors['INFO']}; }}
        .severity-badge {{
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }}
        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }}
        th {{
            background-color: #f0f0f0;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Vulnerability Scan Report</h1>
        <p><strong>Target:</strong> {self.results['target']}</p>
        <p><strong>Scan Type:</strong> {self.results['scan_type']}</p>
        <p><strong>Date:</strong> {self.results['timestamp']}</p>
        
        <h2>Summary</h2>
        <div class="summary">
            <div class="summary-item critical">
                <h3>{self.results['summary']['critical']}</h3>
                <p>Critical</p>
            </div>
            <div class="summary-item high">
                <h3>{self.results['summary']['high']}</h3>
                <p>High</p>
            </div>
            <div class="summary-item medium">
                <h3>{self.results['summary']['medium']}</h3>
                <p>Medium</p>
            </div>
            <div class="summary-item low">
                <h3>{self.results['summary']['low']}</h3>
                <p>Low</p>
            </div>
            <div class="summary-item info">
                <h3>{self.results['summary']['info']}</h3>
                <p>Info</p>
            </div>
        </div>
        
        <h2>Vulnerability Details</h2>
"""
        
        # Sort vulnerabilities by severity
        severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'INFO': 4}
        sorted_vulns = sorted(
            self.results['vulnerabilities'],
            key=lambda x: severity_order.get(x.get('severity', 'INFO'), 5)
        )
        
        for vuln in sorted_vulns:
            severity = vuln.get('severity', 'INFO')
            severity_lower = severity.lower()
            
            html += f"""
        <div class="vulnerability {severity_lower}">
            <span class="severity-badge {severity_lower}">{severity}</span>
            <strong>{vuln.get('type', 'Unknown')}</strong> - {vuln.get('tool', 'Unknown Tool')}
            <p><strong>Host:</strong> {vuln.get('host', 'N/A')}</p>
            <p><strong>Description:</strong> {vuln.get('description', 'No description available')}</p>
            <p><strong>Recommendation:</strong> {vuln.get('recommendation', 'No recommendation available')}</p>
"""
            
            # Add additional details if available
            for key in ['port', 'service', 'path', 'header', 'parameter']:
                if key in vuln:
                    html += f"            <p><strong>{key.title()}:</strong> {vuln[key]}</p>\n"
                    
            html += "        </div>\n"
            
        html += """
    </div>
</body>
</html>
"""
        
        with open(filename, 'w') as f:
            f.write(html)
            
    def _generate_text_summary(self, filename: str):
        """Generate text summary of findings"""
        with open(filename, 'w') as f:
            f.write("=" * 80 + "\n")
            f.write("VULNERABILITY SCAN SUMMARY\n")
            f.write("=" * 80 + "\n\n")
            f.write(f"Target: {self.results['target']}\n")
            f.write(f"Scan Type: {self.results['scan_type']}\n")
            f.write(f"Date: {self.results['timestamp']}\n\n")
            
            f.write("STATISTICS:\n")
            f.write("-" * 40 + "\n")
            for severity, count in self.results['summary'].items():
                f.write(f"{severity.upper():<10} : {count}\n")
                
            f.write("\n" + "=" * 80 + "\n")
            f.write("TOP VULNERABILITIES:\n")
            f.write("=" * 80 + "\n\n")
            
            # Show top 10 most severe vulnerabilities
            severity_order = {'CRITICAL': 0, 'HIGH': 1, 'MEDIUM': 2, 'LOW': 3, 'INFO': 4}
            sorted_vulns = sorted(
                self.results['vulnerabilities'],
                key=lambda x: severity_order.get(x.get('severity', 'INFO'), 5)
            )[:10]
            
            for i, vuln in enumerate(sorted_vulns, 1):
                f.write(f"{i}. [{vuln.get('severity', 'INFO')}] {vuln.get('type', 'Unknown')}\n")
                f.write(f"   Host: {vuln.get('host', 'N/A')}\n")
                f.write(f"   Description: {vuln.get('description', 'N/A')}\n")
                f.write(f"   Recommendation: {vuln.get('recommendation', 'N/A')}\n\n")
                
    def run_scan(self):
        """Execute full vulnerability scan"""
        print(f"""
╔══════════════════════════════════════════╗
║     Automated Vulnerability Scanner      ║
╚══════════════════════════════════════════╝

Target: {self.target}
Scan Type: {self.scan_type}
Output Directory: {self.output_dir}
""")
        
        # Check available tools
        print("[*] Checking available tools...")
        available_tools = self.check_tool_availability()
        print(f"[*] Available tools: {', '.join([t for t, a in available_tools.items() if a])}")
        
        all_vulnerabilities = []
        
        # Run scans based on available tools
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = []
            
            # Always run these checks
            futures.append(executor.submit(self.check_headers))
            futures.append(executor.submit(self.sql_injection_scan))
            
            # Tool-specific scans
            if available_tools.get('nmap'):
                futures.append(executor.submit(self.nmap_scan))
                
            if available_tools.get('nikto') and self.target.startswith('http'):
                futures.append(executor.submit(self.nikto_scan))
                
            if available_tools.get('testssl') and self.target.startswith('https'):
                futures.append(executor.submit(self.testssl_scan))
                
            if available_tools.get('nuclei'):
                futures.append(executor.submit(self.nuclei_scan))
                
            if available_tools.get('gobuster') and self.target.startswith('http'):
                futures.append(executor.submit(self.directory_fuzzing))
                
            # Collect results
            for future in as_completed(futures):
                try:
                    result = future.result()
                    all_vulnerabilities.extend(result)
                except Exception as e:
                    print(f"[!] Scan error: {e}")
                    
        # Aggregate and generate reports
        self.aggregate_results(all_vulnerabilities)
        self.generate_report()
        
        # Print summary
        print(f"""
[+] Scan completed!

Summary:
- Critical: {self.results['summary']['critical']}
- High: {self.results['summary']['high']}
- Medium: {self.results['summary']['medium']}
- Low: {self.results['summary']['low']}
- Info: {self.results['summary']['info']}

Total vulnerabilities found: {len(self.results['vulnerabilities'])}
Reports saved to: {self.output_dir}/
""")

def main():
    parser = argparse.ArgumentParser(description='Automated Vulnerability Scanner')
    parser.add_argument('target', help='Target URL or IP address')
    parser.add_argument('--scan-type', choices=['quick', 'full'], default='full',
                       help='Type of scan to perform')
    parser.add_argument('--output', help='Custom output directory')
    
    args = parser.parse_args()
    
    # Validate target
    if not args.target.startswith(('http://', 'https://')):
        # Assume it's an IP or hostname, prepend https://
        args.target = f"https://{args.target}"
        
    # Create scanner and run
    scanner = VulnerabilityScanner(args.target, args.scan_type)
    
    if args.output:
        scanner.output_dir = args.output
        os.makedirs(scanner.output_dir, exist_ok=True)
        
    try:
        scanner.run_scan()
    except KeyboardInterrupt:
        print("\n[!] Scan interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[!] Scan failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()