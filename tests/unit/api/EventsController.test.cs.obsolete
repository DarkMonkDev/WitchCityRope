using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Moq;
using WitchCityRope.Api.Models;
using Xunit;
using FluentAssertions;

namespace WitchCityRope.Api.Tests.Controllers;

/// <summary>
/// OBSOLETE: EventsController has been migrated to minimal API endpoints
/// This test file references deleted services (IEventService, EventsController)
/// Architecture migrated to vertical slice pattern with minimal APIs
/// New location: /apps/api/Features/Events/Endpoints/EventEndpoints.cs
///
/// Tests are skipped until new endpoint tests are created
/// </summary>
public class EventsControllerTests
{
    private readonly Mock<IEventService> _mockEventService;
    private readonly Mock<ILogger<EventsController>> _mockLogger;
    private readonly EventsController _controller;
    private readonly CancellationToken _cancellationToken;

    public EventsControllerTests()
    {
        _mockEventService = new Mock<IEventService>();
        _mockLogger = new Mock<ILogger<EventsController>>();
        _controller = new EventsController(_mockEventService.Object, _mockLogger.Object);
        _cancellationToken = CancellationToken.None;
    }

    [Fact(Skip = "OBSOLETE: EventsController migrated to minimal API endpoints")]
    public async Task GetEvents_WithDatabaseEvents_ReturnsOkWithEventList()
    {
        // Arrange
        var testEvents = new List<EventDto>
        {
            new EventDto
            {
                Id = "550e8400-e29b-41d4-a716-446655440000",
                Title = "Database Event 1",
                Description = "Test event from database",
                StartDate = new DateTime(2025, 8, 25, 14, 0, 0, DateTimeKind.Utc),
                Location = "Test Location"
            },
            new EventDto
            {
                Id = "550e8400-e29b-41d4-a716-446655440001",
                Title = "Database Event 2",
                Description = "Another test event from database",
                StartDate = new DateTime(2025, 8, 30, 19, 0, 0, DateTimeKind.Utc),
                Location = "Another Test Location"
            }
        };

        _mockEventService
            .Setup(x => x.GetPublishedEventsAsync(_cancellationToken))
            .ReturnsAsync(testEvents);

        // Act
        var result = await _controller.GetEvents(_cancellationToken);

        // Assert
        result.Should().NotBeNull();
        var actionResult = result.Result as OkObjectResult;
        actionResult.Should().NotBeNull();
        actionResult!.StatusCode.Should().Be(200);
        
        var returnedEvents = actionResult.Value as IEnumerable<EventDto>;
        returnedEvents.Should().NotBeNull();
        returnedEvents.Should().HaveCount(2);
        returnedEvents!.First().Title.Should().Be("Database Event 1");
        
        _mockEventService.Verify(x => x.GetPublishedEventsAsync(_cancellationToken), Times.Once);
    }

    [Fact]
    public async Task GetEvents_WithEmptyDatabase_ReturnsFallbackEvents()
    {
        // Arrange
        _mockEventService
            .Setup(x => x.GetPublishedEventsAsync(_cancellationToken))
            .ReturnsAsync(new List<EventDto>());

        // Act
        var result = await _controller.GetEvents(_cancellationToken);

        // Assert
        result.Should().NotBeNull();
        var actionResult = result.Result as OkObjectResult;
        actionResult.Should().NotBeNull();
        actionResult!.StatusCode.Should().Be(200);
        
        var returnedEvents = actionResult.Value as IEnumerable<EventDto>;
        returnedEvents.Should().NotBeNull();
        returnedEvents.Should().HaveCount(3); // Fallback events count
        returnedEvents!.First().Title.Should().Contain("Fallback");
        
        _mockEventService.Verify(x => x.GetPublishedEventsAsync(_cancellationToken), Times.Once);
    }

    [Fact]
    public async Task GetEvents_WithDatabaseException_ReturnsFallbackEvents()
    {
        // Arrange
        _mockEventService
            .Setup(x => x.GetPublishedEventsAsync(_cancellationToken))
            .ThrowsAsync(new Exception("Database connection failed"));

        // Act
        var result = await _controller.GetEvents(_cancellationToken);

        // Assert
        result.Should().NotBeNull();
        var actionResult = result.Result as OkObjectResult;
        actionResult.Should().NotBeNull();
        actionResult!.StatusCode.Should().Be(200);
        
        var returnedEvents = actionResult.Value as IEnumerable<EventDto>;
        returnedEvents.Should().NotBeNull();
        returnedEvents.Should().HaveCount(3); // Fallback events count
        returnedEvents!.First().Title.Should().Contain("Fallback");
        
        _mockEventService.Verify(x => x.GetPublishedEventsAsync(_cancellationToken), Times.Once);
    }

    [Fact]
    public async Task GetEvents_ReturnsEventDtoArray_ProveStackWorks()
    {
        // Arrange - Test that proves the React + API + PostgreSQL stack works
        var testEvents = new List<EventDto>
        {
            new EventDto
            {
                Id = Guid.NewGuid().ToString(),
                Title = "Proof of Concept Event",
                Description = "This event proves React ↔ API ↔ PostgreSQL communication works",
                StartDate = DateTime.UtcNow.AddDays(7),
                Location = "Proof of Concept Location"
            }
        };

        _mockEventService
            .Setup(x => x.GetPublishedEventsAsync(_cancellationToken))
            .ReturnsAsync(testEvents);

        // Act
        var result = await _controller.GetEvents(_cancellationToken);

        // Assert
        result.Should().NotBeNull();
        var actionResult = result.Result as OkObjectResult;
        actionResult.Should().NotBeNull();
        
        var returnedEvents = actionResult.Value as IEnumerable<EventDto>;
        returnedEvents.Should().NotBeNull();
        returnedEvents.Should().BeAssignableTo<IEnumerable<EventDto>>();
        
        // Verify the shape matches what React expects
        var firstEvent = returnedEvents!.First();
        firstEvent.Id.Should().NotBeNullOrEmpty();
        firstEvent.Title.Should().NotBeNullOrEmpty();
        firstEvent.Description.Should().NotBeNullOrEmpty();
        firstEvent.StartDate.Should().BeAfter(DateTime.UtcNow);
        firstEvent.Location.Should().NotBeNullOrEmpty();
    }

    [Fact]
    public async Task GetEvents_AllDateTimesAreUtc_ProvePostgreSqlCompatibility()
    {
        // Arrange - Test that ensures all DateTime values are UTC for PostgreSQL
        var testEvents = new List<EventDto>
        {
            new EventDto
            {
                Id = Guid.NewGuid().ToString(),
                Title = "UTC DateTime Test",
                Description = "Test UTC DateTime for PostgreSQL compatibility",
                StartDate = new DateTime(2025, 8, 25, 14, 0, 0, DateTimeKind.Utc),
                Location = "UTC Test Location"
            }
        };

        _mockEventService
            .Setup(x => x.GetPublishedEventsAsync(_cancellationToken))
            .ReturnsAsync(testEvents);

        // Act
        var result = await _controller.GetEvents(_cancellationToken);

        // Assert
        var actionResult = result.Result as OkObjectResult;
        var returnedEvents = actionResult!.Value as IEnumerable<EventDto>;
        var firstEvent = returnedEvents!.First();
        
        // PostgreSQL requires UTC DateTime values
        firstEvent.StartDate.Kind.Should().Be(DateTimeKind.Utc);
    }
}