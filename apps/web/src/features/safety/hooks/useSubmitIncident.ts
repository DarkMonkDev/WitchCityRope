// Specialized hook for incident submission with form integration
// Provides enhanced form submission with validation and status tracking

import { useState, useCallback } from 'react';
import { useSubmitIncident } from './useSafetyIncidents';
import type { IncidentFormData, SubmitIncidentRequest } from '../types/safety.types';

/**
 * Enhanced incident submission hook with form integration
 * Handles form data conversion and submission state
 */
export function useSubmitIncidentForm() {
  const [submissionResult, setSubmissionResult] = useState<{
    referenceNumber?: string;
    trackingUrl?: string;
    submittedAt?: string;
  } | null>(null);
  
  const submitMutation = useSubmitIncident();
  
  /**
   * Convert form data to API request format
   */
  const convertFormDataToRequest = useCallback((formData: IncidentFormData, reporterId?: string): SubmitIncidentRequest => {
    // Combine date and time into ISO string
    const incidentDateTime = new Date(`${formData.incidentDate}T${formData.incidentTime}`);

    return {
      reporterId: formData.isAnonymous ? undefined : reporterId,
      // Title is auto-generated by backend from incidentType and date
      title: undefined,
      incidentDate: incidentDateTime.toISOString(),
      location: formData.location,
      description: formData.description,
      involvedParties: formData.involvedParties || undefined,
      witnesses: formData.witnesses || undefined,
      isAnonymous: formData.isAnonymous,
      requestFollowUp: formData.requestFollowUp,
      contactEmail: (!formData.isAnonymous && formData.contactEmail) ? formData.contactEmail : undefined,
      contactName: (!formData.isAnonymous && formData.contactName) ? formData.contactName : undefined,
      // New wireframe fields
      type: formData.incidentType,
      whereOccurred: formData.whereOccurred,
      eventName: formData.eventName || undefined,
      hasSpokenToPerson: formData.hasSpokenToPerson !== '' ? formData.hasSpokenToPerson : undefined,
      desiredOutcomes: formData.desiredOutcomes || undefined,
      futureInteractionPreference: formData.futureInteractionPreference || undefined,
      anonymousDuringInvestigation: formData.anonymousDuringInvestigation,
      anonymousInFinalReport: formData.anonymousInFinalReport
    };
  }, []);
  
  /**
   * Submit incident with form data
   */
  const submitIncident = useCallback(async (formData: IncidentFormData, reporterId?: string) => {
    try {
      const request = convertFormDataToRequest(formData, reporterId);
      const result = await submitMutation.mutateAsync(request);
      
      setSubmissionResult({
        referenceNumber: (result as any)?.referenceNumber,
        trackingUrl: (result as any)?.trackingUrl,
        submittedAt: (result as any)?.submittedAt
      });
      
      return result;
    } catch (error) {
      console.error('Form submission failed:', error);
      throw error;
    }
  }, [convertFormDataToRequest, submitMutation]);
  
  /**
   * Reset submission state
   */
  const resetSubmission = useCallback(() => {
    setSubmissionResult(null);
    // Check if reset method exists before calling it
    if ('reset' in submitMutation && typeof submitMutation.reset === 'function') {
      submitMutation.reset();
    }
  }, [submitMutation]);
  
  return {
    submitIncident,
    resetSubmission,
    submissionResult,
    isSubmitting: submitMutation.isPending,
    error: submitMutation.error,
    isSuccess: submitMutation.isSuccess && !!submissionResult
  };
}